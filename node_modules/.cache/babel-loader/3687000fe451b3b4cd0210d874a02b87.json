{"ast":null,"code":"const fetch = require('node-fetch');\n\nconst _ = require('./utils');\n\nmodule.exports = function api(options, callback) {\n  // Set the url to options.uri or options.url..\n  let url = options.url !== undefined ? options.url : options.uri; // Make sure it is a valid url..\n\n  if (!_.isURL(url)) {\n    url = `https://api.twitch.tv/kraken${url[0] === '/' ? url : `/${url}`}`;\n  } // We are inside a Node application, so we can use the node-fetch module..\n\n\n  if (_.isNode()) {\n    const opts = Object.assign({\n      method: 'GET',\n      json: true\n    }, options);\n\n    if (opts.qs) {\n      const qs = new URLSearchParams(opts.qs);\n      url += `?${qs}`;\n    }\n    /** @type {import('node-fetch').RequestInit} */\n\n\n    const fetchOptions = {};\n\n    if ('fetchAgent' in this.opts.connection) {\n      fetchOptions.agent = this.opts.connection.fetchAgent;\n    }\n    /** @type {ReturnType<import('node-fetch')['default']>} */\n\n\n    const fetchPromise = fetch(url, { ...fetchOptions,\n      method: opts.method,\n      headers: opts.headers,\n      body: opts.body\n    });\n    let response = {};\n    fetchPromise.then(res => {\n      response = {\n        statusCode: res.status,\n        headers: res.headers\n      };\n      return opts.json ? res.json() : res.text();\n    }).then(data => callback(null, response, data), err => callback(err, response, null));\n  } // Web application, extension, React Native etc.\n  else {\n    const opts = Object.assign({\n      method: 'GET',\n      headers: {}\n    }, options, {\n      url\n    }); // prepare request\n\n    const xhr = new XMLHttpRequest();\n    xhr.open(opts.method, opts.url, true);\n\n    for (const name in opts.headers) {\n      xhr.setRequestHeader(name, opts.headers[name]);\n    }\n\n    xhr.responseType = 'json'; // set request handler\n\n    xhr.addEventListener('load', _ev => {\n      if (xhr.readyState === 4) {\n        if (xhr.status !== 200) {\n          callback(xhr.status, null, null);\n        } else {\n          callback(null, null, xhr.response);\n        }\n      }\n    }); // submit\n\n    xhr.send();\n  }\n};","map":{"version":3,"sources":["D:/Programming Projects/twitch-chat-combiner-js/node_modules/tmi.js/lib/api.js"],"names":["fetch","require","_","module","exports","api","options","callback","url","undefined","uri","isURL","isNode","opts","Object","assign","method","json","qs","URLSearchParams","fetchOptions","connection","agent","fetchAgent","fetchPromise","headers","body","response","then","res","statusCode","status","text","data","err","xhr","XMLHttpRequest","open","name","setRequestHeader","responseType","addEventListener","_ev","readyState","send"],"mappings":"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","sourcesContent":["const fetch = require('node-fetch');\nconst _ = require('./utils');\n\nmodule.exports = function api(options, callback) {\n\t// Set the url to options.uri or options.url..\n\tlet url = options.url !== undefined ? options.url : options.uri;\n\n\t// Make sure it is a valid url..\n\tif(!_.isURL(url)) {\n\t\turl = `https://api.twitch.tv/kraken${url[0] === '/' ? url : `/${url}`}`;\n\t}\n\n\t// We are inside a Node application, so we can use the node-fetch module..\n\tif(_.isNode()) {\n\t\tconst opts = Object.assign({ method: 'GET', json: true }, options);\n\t\tif(opts.qs) {\n\t\t\tconst qs = new URLSearchParams(opts.qs);\n\t\t\turl += `?${qs}`;\n\t\t}\n\t\t/** @type {import('node-fetch').RequestInit} */\n\t\tconst fetchOptions = {};\n\t\tif('fetchAgent' in this.opts.connection) {\n\t\t\tfetchOptions.agent = this.opts.connection.fetchAgent;\n\t\t}\n\t\t/** @type {ReturnType<import('node-fetch')['default']>} */\n\t\tconst fetchPromise = fetch(url, {\n\t\t\t...fetchOptions,\n\t\t\tmethod: opts.method,\n\t\t\theaders: opts.headers,\n\t\t\tbody: opts.body\n\t\t});\n\t\tlet response = {};\n\t\tfetchPromise.then(res => {\n\t\t\tresponse = { statusCode: res.status, headers: res.headers };\n\t\t\treturn opts.json ? res.json() : res.text();\n\t\t})\n\t\t.then(\n\t\t\tdata => callback(null, response, data),\n\t\t\terr => callback(err, response, null)\n\t\t);\n\t}\n\t// Web application, extension, React Native etc.\n\telse {\n\t\tconst opts = Object.assign({ method: 'GET', headers: {} }, options, { url });\n\t\t// prepare request\n\t\tconst xhr = new XMLHttpRequest();\n\t\txhr.open(opts.method, opts.url, true);\n\t\tfor(const name in opts.headers) {\n\t\t\txhr.setRequestHeader(name, opts.headers[name]);\n\t\t}\n\t\txhr.responseType = 'json';\n\t\t// set request handler\n\t\txhr.addEventListener('load', _ev => {\n\t\t\tif(xhr.readyState === 4) {\n\t\t\t\tif(xhr.status !== 200) {\n\t\t\t\t\tcallback(xhr.status, null, null);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallback(null, null, xhr.response);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t// submit\n\t\txhr.send();\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}